# -*- coding: utf-8 -*-
"""Actuarial mathematic github.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wF8-OCxJvkFuXvEHMy5gCasXilILAtzY

Imports
"""

import pandas as pd
import numpy as np
import inspect

"""Actuarial Calculation Class"""

class ActuarialCalculator:
    """
    A class for actuarial calculations based on a given life table and interest rate.
    The life table is expected to be a pandas DataFrame with 'age' and 'lx' columns.
    """
    # --- 1. Initializer and Core Setup ---
    # ---------------------------------------
    def __init__(self, life_table_df: pd.DataFrame, interest_rate: float):
        """
        Initializes the calculator with a life table and interest rate.

        Args:
            life_table_df (pd.DataFrame): DataFrame containing life table data.
                                          Must have 'age' and 'lx' columns.
            interest_rate (float): The effective annual interest rate (e.g., 0.05 for 5%).
        """
        if not isinstance(life_table_df, pd.DataFrame) or not all(col in life_table_df.columns for col in ['age', 'lx']):
            raise ValueError("life_table_df must be a pandas DataFrame with 'age' and 'lx' columns.")

        self.i = interest_rate
        self.v = 1 / (1 + self.i)
        self.delta = np.log(1 + self.i)
        self.d = 1 - self.v # d = 1 - v = i / (1+i)
        self.d_m = {m: m * (1 - self.v**(1/m)) for m in range(1, 13)} # Pre-calculates d^(m) for m=1 to 12
        self.i_m = {m: m * ((1 + self.i)**(1/m) - 1) for m in range(1, 13)}

        # --- Data Preparation ---
        # Set age as index for fast lookups (O(1) access)
        self.life_table = life_table_df.set_index('age').copy()

        # Automatically calculate dx and qx
        # dx = lx - l_{x+1}
        self.life_table['dx'] = self.life_table['lx'].diff(periods=-1)
        # qx = dx / lx
        self.life_table['qx'] = self.life_table['dx'] / self.life_table['lx']

        # Fill the last dx and qx with appropriate values
        self.life_table.loc[self.life_table.index.max(), 'dx'] = self.life_table.loc[self.life_table.index.max(), 'lx']
        self.life_table.loc[self.life_table.index.max(), 'qx'] = 1.0

        self.max_age = self.life_table.index.max()

    def validate_inputs(self, x: int, n: int = None):
        """Validates age and optional term length."""
        if not (self.life_table.index.min() <= x <= self.max_age):
            raise ValueError(f"Age x ({x}) is out of the life table's range.")
        if n is not None:
            if x + n > self.max_age + 1: # Allow up to the end of the table
                raise ValueError(f"Age x + n ({x + n}) exceeds limiting age {self.max_age}.")
            if n < 1:
                raise ValueError("Term n must be at least 1 year.")


    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                       Insurance Benefit


    ## ------------------------------------------------------------------
    ##  1: Annual Term Insurance
    ## ------------------------------------------------------------------

    def annual_term_insurance(self, x: int, n: int):
        """
        Calculates EPV of annual term insurance A^1_{x:n|} using the efficient computational formula.
        Formula: (1/lx) * sum(v^(k+1) * d_{x+k}) for k=0 to n-1
        """
        self.validate_inputs(x, n)

        # Fast lookup using .loc
        lx_start = self.life_table.loc[x, 'lx']

        # Get the series of d_{x+k} values for k=0 to n-1
        dx_values = self.life_table.loc[x : x + n - 1, 'dx']

        # Efficient summation using vectorization
        k = np.arange(n)
        v_powers = self.v ** (k + 1)

        # The core calculation
        discounted_sum = np.sum(dx_values.values * v_powers)

        epv = discounted_sum / lx_start
        return epv


    ## ------------------------------------------------------------------
    ##  Helper for fractional ages
    ## ------------------------------------------------------------------
    def _get_lx_t(self, age_float: float):
        """
        Calculates l_x for a non-integer age using UDD: lx+t = lx - t*dx.

        """
        base_age = int(age_float)
        fraction = age_float - base_age

        if fraction == 0:
            return self.life_table.loc[base_age, 'lx']

        # Ensure we don't go past the table's limits
        if base_age >= self.max_age:
            return self.life_table.loc[self.max_age, 'lx'] * (1 - fraction)

        lx_base = self.life_table.loc[base_age, 'lx']
        dx_base = self.life_table.loc[base_age, 'dx']

        # UDD formula: l_{x+t} = l_x - t*d_x
        return lx_base - fraction * dx_base


    ## ------------------------------------------------------------------
    ##  2: M-thly Term Insurance
    ## ------------------------------------------------------------------
    def mthly_term_insurance(self, x: int, n: int, m: int):
        """
        Calculates EPV of m-thly term insurance using direct summation.

        """
        self.validate_inputs(x, n)
        if not isinstance(m, int) or m < 1:
            raise ValueError("m must be a positive integer.")

        lx_start = self.life_table.loc[x, 'lx']
        total_periods = m * n
        epv = 0.0

        for k in range(total_periods):
            time_start_period = k / m
            time_end_period = (k + 1) / m

            # Use the internal helper method to get fractional lx values
            lx_period_start = self._get_lx_t(x + time_start_period)
            lx_period_end = self._get_lx_t(x + time_end_period)

            # Probability of dying in this specific 1/m period
            prob_of_death_in_period = (lx_period_start - lx_period_end) / lx_start

            # Discount factor for payment at the end of the period
            discount = self.v ** time_end_period

            epv += discount * prob_of_death_in_period

        return epv


    ## ------------------------------------------------------------------
    ##  3: Pure Endowment
    ## ------------------------------------------------------------------
    def pure_endowment(self, x: int, n: int):
        """
        Calculates the EPV of an n-year pure endowment of 1.
        Formula: v^n * nPx

        Args:
            x (int): The age of the insured.
            n (int): The term of the endowment in years.

        Returns:
            float: The expected present value (EPV) of the pure endowment.
        """
        # 1. Validate inputs to ensure they are within the table's range
        self.validate_inputs(x, n)

        # 2. Calculate the probability of survival, nPx = l_{x+n} / l_x
        lx_start = self.life_table.loc[x, 'lx']
        lx_future = self.life_table.loc[x + n, 'lx']
        n_px = lx_future / lx_start

        # 3. Calculate the discount factor v^n
        discount_factor = self.v ** n

        # 4. Calculate the final EPV
        epv = discount_factor * n_px

        return epv


    ## ------------------------------------------------------------------
    ##  3: Endowment Insurance (Annual / M-thly)
    ## ------------------------------------------------------------------
    def endowment_insurance(self, x: int, n: int, m: int = 1):
        """
        Calculates the EPV of an n-year endowment insurance of 1.

        This is a combination of an n-year term insurance and an n-year pure endowment.
        Formula: A_{x:n|} = A^1_{x:n|} + A_{x:n|}^1

        Args:
            x (int): The age of the insured.
            n (int): The term of the policy in years.
            m (int): Number of periods per year for the death benefit.
                     Defaults to 1 (annual). Set to > 1 for m-thly.

        Returns:
            float: The expected present value (EPV) of the endowment insurance.
        """
        # 1. Validate inputs
        self.validate_inputs(x, n)

        # 2. Calculate the EPV of the pure endowment component
        pure_endowment_epv = self.pure_endowment(x, n)

        # 3. Calculate the EPV of the term insurance component
        if m == 1:
            # Standard annual term insurance
            term_insurance_epv = self.annual_term_insurance(x, n)
        else:
            # M-thly term insurance using the direct summation method
            term_insurance_epv = self.mthly_term_insurance(x, n, m)
            # Or use the approximation method if you prefer:
            # term_insurance_epv = self.mthly_term_insurance_approx(x, n, m)

        # 4. The total EPV is the sum of the two components
        total_epv = term_insurance_epv + pure_endowment_epv

        return total_epv


    ## ------------------------------------------------------------------
    ##  4: Defferred Term Insurance (Annual / M-thly)
    ## ------------------------------------------------------------------
    def deferred_term_insurance(self, x: int, u: int, n: int, m: int = 1):
        """
        Calculates the EPV of a deferred term insurance.
        It can handle both annual (m=1) and m-thly (m>1) payments.
        Uses the discounting approach: n|A{x+u^1:n} = nEx * A_{x+u^1:n}

        Args:
            x (int): The initial age of the insured.
            u (int): The deferral period in years.
            n (int): The term of insurance coverage after the deferral period.
            m (int): Number of payment periods per year. Defaults to 1 (annual).

        Returns:
            float: The expected present value (EPV) of the deferred insurance.
        """
        # 1. Validate inputs
        self.validate_inputs(x, u + n)
        if u < 0:
            raise ValueError("Deferral period u must be non-negative.")
        if n < 1:
            raise ValueError("Term n must be at least 1 year.")

        # 2. Calculate the actuarial discount factor using the pure_endowment method.
        # This is the key improvement based on your suggestion.
        u_E_x = self.pure_endowment(x, u)

        # 3. Calculate the value of the term insurance that starts AT time u.
        if m == 1:
            future_insurance_value = self.annual_term_insurance(x + u, n)
        else:
            future_insurance_value = self.mthly_term_insurance(x + u, n, m)

        # 4. The final EPV is the discounted value of the future insurance.
        epv = u_E_x * future_insurance_value

        return epv



    ## ------------------------------------------------------------------
    ##  5: Helper Whole Life Insurance (Annual / M-thly)
    ## ------------------------------------------------------------------
    def whole_life_insurance(self, x: int, m: int = 1):
        """
        Calculates the EPV of a whole life insurance.
        Handles both annual (m=1) and m-thly (m>1) payments.

        It uses backward recursion for efficiency and caches the results.

        Args:
            x (int): The age of the insured.
            m (int): Number of payment periods per year. Defaults to 1 (annual).

        Returns:
            float: The expected present value (EPV) of the whole life insurance.
        """
        # --- Step 0: Input Validation ---
        self.validate_inputs(x)
        if m < 1:
            raise ValueError("m must be a positive integer.")

        # --- Step 1: Calculate all annual Ax values using backward recursion ---
        # We use a cache (_Ax_cache) to avoid re-calculating this every time.
        if not hasattr(self, '_Ax_cache'):
            # Create a new column in our life_table DataFrame for 'Ax'
            self.life_table['Ax'] = 0.0

            # Get the highest age (omega) from the table
            max_age = self.max_age

            # Initialize the last value: A_omega = v * q_omega
            # Since q_omega is 1, A_omega is just v.
            self.life_table.loc[max_age, 'Ax'] = self.v

            # Work backwards from the second to last age down to the first
            for age in range(max_age - 1, self.life_table.index.min() - 1, -1):
                q_age = self.life_table.loc[age, 'qx']
                p_age = 1 - q_age
                Ax_plus_1 = self.life_table.loc[age + 1, 'Ax']

                # The recursive formula: Ax = v * (qx + px * A_{x+1})
                self.life_table.loc[age, 'Ax'] = self.v * (q_age + p_age * Ax_plus_1)

            # Store the results in the cache
            self._Ax_cache = self.life_table['Ax']

        # --- Step 2: Retrieve the annual value for the requested age x ---
        annual_Ax = self._Ax_cache.loc[x]

        # --- Step 3: Adjust for m-thly payments if necessary ---
        if m == 1:
            return annual_Ax
        else:
            # Using the UDD approximation: A^(m) = (i / i^(m)) * A
            if self.i == 0:
                i_ratio = 1.0
            else:
                i_m = m * ((1 + self.i)**(1/m) - 1)
                i_ratio = self.i / i_m

            return i_ratio * annual_Ax


    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                     Annuities



    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                   Certain annuities
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


    ## ------------------------------------------------------------------
    ##  Helper: Annuity Certain
    ## ------------------------------------------------------------------

    def annuity_certain(self, n: int, m: int = 1, timing: str = 'due'):
        """
        Calculates the value of an annuity-certain.
        Handles annual (m=1) and m-thly (m>1) cases for both due and immediate.

        Args:
            n (int): The term of the annuity in years.
            m (int): Number of payments per year. Defaults to 1.
            timing (str): Type of annuity, 'due' or 'immediate'. Defaults to 'due'.

        Returns:
            float: The present value of the annuity-certain.
        """
        if n < 0:
            raise ValueError("Term n must be non-negative.")
        if n == 0:
            return 0.0
        if self.i == 0: # Edge case for zero interest
            return n if timing == 'due' else n # This is a simplification

        v_n = self.v ** n

        if timing == 'due':
            if m == 1: # annual due
                return (1 - v_n) / self.d
            else: # m-thly due
                return (1 - v_n) / self.d_m[m]
        elif timing == 'immediate':
            if m == 1: # annual immediate
                return (1 - v_n) / self.i
            else: # m-thly immediate
                return (1 - v_n) / self.i_m[m]
        else:
            raise ValueError("Timing must be 'due' or 'immediate'.")


    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                 Annual life annuities
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


    ## ------------------------------------------------------------------
    ##  1: Whole Life Annuity Due
    ## ------------------------------------------------------------------
    def whole_life_annuity_due(self, x: int):
        """
        Calculates the EPV of a whole life annuity-due.
        Formula: (1 - Ax) / d
        """
        # 1. Validate age
        self.validate_inputs(x)

        # 2. Check for the zero-interest rate edge case
        if self.d == 0:
            # When i=0, the formula is indeterminate (0/0).
            # The value is the complete expectation of life, which requires
            # a different calculation method (direct summation).
            raise ValueError("Formula (1-Ax)/d is not applicable when interest rate is 0.")

        # 3. Get the whole life insurance value (annual)
        # This will use our efficient, cached calculation for Ax
        Ax = self.whole_life_insurance(x, m=1)

        # 4. Apply the formula
        annuity_due_epv = (1 - Ax) / self.d

        return annuity_due_epv
    ## ------------------------------------------------------------------
    ##  2: Whole Life Annuity Immediate
    ## ------------------------------------------------------------------
    def whole_life_annuity_immediate(self, x: int):
        """
        Calculates the EPV of a whole life annuity-immediate.
        Formula: a_x = a_due_x - 1
        """
        # 1. Validate age
        self.validate_inputs(x)

        # 2. The value is simply the annuity-due minus the first payment of 1
        annuity_due_epv = self.whole_life_annuity_due(x)

        return annuity_due_epv - 1


    ## ------------------------------------------------------------------
    ##  3: Term Annuity Due
    ## ------------------------------------------------------------------
    def term_annuity_due(self, x: int, n: int):
        """
        Calculates the EPV of an n-year term annuity-due.
        Formula: (1 - A_{x:n|}) / d
        """
        # 1. Validate inputs
        self.validate_inputs(x, n)

        # 2. Check for the zero-interest rate edge case
        if self.d == 0:
            raise ValueError("Formula is not applicable when interest rate is 0.")

        # 3. Get the value of the corresponding endowment insurance (annual)
        # We reuse the method we created earlier.
        A_xn = self.endowment_insurance(x, n, m=1)

        # 4. Apply the formula
        epv = (1 - A_xn) / self.d

        return epv

    ## ------------------------------------------------------------------
    ##  4: Term Annuity Immediate
    ## ------------------------------------------------------------------
    def term_annuity_immediate(self, x: int, n: int):
        """
        Calculates the EPV of an n-year term annuity-immediate.
        Formula: a_due_{x:n|} - 1 + nEx
        """
        # 1. Validate inputs
        self.validate_inputs(x, n)

        # 2. Calculate the annuity-due component
        a_due_xn = self.term_annuity_due(x, n)

        # 3. Calculate the pure endowment component (nEx)
        n_E_x = self.pure_endowment(x, n)

        # 4. Apply the formula: a_due - 1 + nEx
        epv = a_due_xn - 1 + n_E_x

        return epv


    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                Annuities payable  M-thly
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


    ## ------------------------------------------------------------------
    ##  1: M-thly Whole Life Annuity Due
    ## ------------------------------------------------------------------
    def mthly_whole_life_annuity_due(self, x: int, m: int):
        """
        Calculates the EPV of a whole life annuity-due payable m-thly.
        Formula: (1 - A_x^(m)) / d^(m)
        """
        # 1. Validate inputs
        self.validate_inputs(x)
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")
        if self.i == 0:
            raise ValueError("Formula is not applicable when interest rate is 0.")

        # 2. Get the m-thly whole life insurance value
        Ax_m = self.whole_life_insurance(x, m=m)

        # 3. Get the pre-calculated nominal discount rate d^(m)
        d_m_val = self.d_m[m]

        # 4. Apply the formula
        epv = (1 - Ax_m) / d_m_val

        return epv

    ## ------------------------------------------------------------------
    ##  2: M-thly Whole Life Annuity Immediate
    ## ------------------------------------------------------------------
    def mthly_whole_life_annuity_immediate(self, x: int, m: int):
        """
        Calculates the EPV of a whole life annuity-immediate payable m-thly.
        Formula: a_due_x^(m) - 1/m
        """
        # 1. Validate inputs
        self.validate_inputs(x)
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")

        # 2. Calculate the corresponding annuity-due
        a_due_xm = self.mthly_whole_life_annuity_due(x, m)

        # 3. Apply the formula
        return a_due_xm - (1/m)

    ## ------------------------------------------------------------------
    ##  3: M-thly Term Annuity Due
    ## ------------------------------------------------------------------
    def mthly_term_annuity_due(self, x: int, n: int, m: int):
        """
        Calculates the EPV of an n-year term annuity-due payable m-thly.
        Formula: (1 - A_xn^(m)) / d^(m)
        """
        # 1. Validate inputs
        self.validate_inputs(x, n)
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")
        if self.i == 0:
            raise ValueError("Formula is not applicable when interest rate is 0.")

        # 2. Get the m-thly endowment insurance value
        A_xn_m = self.mthly_endowment_insurance(x, n, m)

        # 3. Get the pre-calculated nominal discount rate d^(m)
        d_m_val = self.d_m[m]

        # 4. Apply the formula
        epv = (1 - A_xn_m) / d_m_val

        return epv


    ## ------------------------------------------------------------------
    ##  4: M-thly Term Annuity Immediate
    ## ------------------------------------------------------------------
    def mthly_term_annuity_immediate(self, x: int, n: int, m: int):
        """
        Calculates the EPV of an n-year term annuity-immediate payable m-thly.
        Formula: a_due_xnm - (1/m) * (1 - nEx)
        """
        # 1. Validate inputs
        self.validate_inputs(x, n)
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")

        # 2. Calculate the corresponding annuity-due
        a_due_xnm = self.mthly_term_annuity_due(x, n, m)

        # 3. Calculate the pure endowment component, nEx
        n_E_x = self.pure_endowment(x, n)

        # 4. Apply the formula
        epv = a_due_xnm - (1/m) * (1 - n_E_x)

        return epv

    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                 Deferred annuities
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


    #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Annual ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ## ------------------------------------------------------------------
    ##  1: Deffered Whole Life Annuity Due
    ## ------------------------------------------------------------------
    def deferred_whole_life_annuity_due(self, x: int, u: int):
        """
        Calculates the EPV of a whole life annuity-due deferred for u years.
        Formula: u|a_due_x = uEx * a_due_{x+u}
        """
        # 1. Validate inputs
        self.validate_inputs(x, u)
        if u < 1:
            raise ValueError("Deferral period u must be at least 1 year.")

        # 2. Calculate the actuarial discount factor (uEx)
        u_E_x = self.pure_endowment(x, u)

        # 3. Calculate the value of the annuity-due at the future age (x+u)
        a_due_xu = self.whole_life_annuity_due(x + u)

        # 4. Apply the formula
        epv = u_E_x * a_due_xu

        return epv


    ## ------------------------------------------------------------------
    ##  1: Deffered Whole Life Annuity Immediate
    ## ------------------------------------------------------------------
    def deferred_whole_life_annuity_immediate(self, x: int, u: int):
        """
        Calculates the EPV of a whole life annuity-immediate deferred for u years.
        Formula: u|a_x = u|a_due_x - uEx
        """
        # 1. Validate inputs
        self.validate_inputs(x, u)
        if u < 1:
            raise ValueError("Deferral period u must be at least 1 year.")

        # 2. Calculate the corresponding deferred annuity-due
        deferred_a_due = self.deferred_whole_life_annuity_due(x, u)

        # 3. Calculate the pure endowment that represents the first payment
        u_E_x = self.pure_endowment(x, u)

        # 4. Apply the formula
        epv = deferred_a_due - u_E_x

        return epv


    #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ M-thly ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    ## ------------------------------------------------------------------
    ##  1: M-thly Deffered Whole Life Annuity Due
    ## ------------------------------------------------------------------

    def deferred_mthly_whole_life_annuity_due(self, x: int, u: int, m: int):
        """
        Calculates the EPV of a whole life annuity-due payable m-thly, deferred for u years.
        Formula: u|a_due_x^(m) = uEx * a_due_{x+u}^(m)
        """
        # 1. Validate inputs
        self.validate_inputs(x, u)
        if u < 1:
            raise ValueError("Deferral period u must be at least 1 year.")
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")

        # 2. Calculate the actuarial discount factor (uEx)
        u_E_x = self.pure_endowment(x, u)

        # 3. Calculate the value of the m-thly annuity-due at the future age (x+u)
        a_due_xu_m = self.mthly_whole_life_annuity_due(x + u, m)

        # 4. Apply the formula
        epv = u_E_x * a_due_xu_m

        return epv

    ## ------------------------------------------------------------------
    ##  2: M-thly Deffered Whole Life Annuity Immediate
    ## ------------------------------------------------------------------
    def deferred_mthly_whole_life_annuity_immediate(self, x: int, u: int, m: int):
        """
        Calculates the EPV of a whole life annuity-immediate payable m-thly, deferred for u years.
        Formula: u|a_x^(m) = u|a_due_x^(m) - (1/m) * uEx
        """
        # 1. Validate inputs
        self.validate_inputs(x, u)
        if u < 1:
            raise ValueError("Deferral period u must be at least 1 year.")
        if m not in self.d_m:
             raise ValueError(f"m must be an integer between 1 and {len(self.d_m)}.")

        # 2. Calculate the corresponding deferred annuity-due
        deferred_a_due_xm = self.deferred_mthly_whole_life_annuity_due(x, u, m)

        # 3. Calculate the pure endowment component
        u_E_x = self.pure_endowment(x, u)

        # 4. Apply the formula to find the immediate annuity value
        epv = deferred_a_due_xm - (1/m) * u_E_x

        return epv


    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                                Guaranteed annuities
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


     #^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Annual ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


    ## ------------------------------------------------------------------
    ##  1: guaranteed Annuity Due (M-thly/Annual)
    ## ------------------------------------------------------------------
    def guaranteed_annuity_due(self, x: int, n: int, m: int = 1):
        """
        Calculates EPV of a whole life annuity-due with first n years guaranteed.
        Formula: a_due_cert_n + nEx * a_due_{x+n}
        """
        self.validate_inputs(x, n)

        # Component 1: The n-year annuity-certain due
        guaranteed_part = self.annuity_certain(n, m=m, timing='due')

        # Component 2: The deferred whole life annuity-due
        n_E_x = self.pure_endowment(x, n)
        if m == 1:
            deferred_part = n_E_x * self.whole_life_annuity_due(x + n)
        else:
            deferred_part = n_E_x * self.mthly_whole_life_annuity_due(x + n, m)

        return guaranteed_part + deferred_part


    ## ------------------------------------------------------------------
    ##  2: guaranteed Annuity Immediate (M-thly/Annual)
    ## ------------------------------------------------------------------

    def guaranteed_annuity_immediate(self, x: int, n: int, m: int = 1):
        """
        Calculates EPV of a whole life annuity-immediate with first n years guaranteed.
        Formula: a_imm_cert_n + nEx * a_imm_{x+n}
        """
        self.validate_inputs(x, n)

        # Component 1: The n-year annuity-certain immediate
        guaranteed_part = self.annuity_certain(n, m=m, timing='immediate')

        # Component 2: The deferred whole life annuity-immediate
        n_E_x = self.pure_endowment(x, n)
        if m == 1:
            deferred_part = n_E_x * self.whole_life_annuity_immediate(x + n)
        else:
            deferred_part = n_E_x * self.mthly_whole_life_annuity_immediate(x + n, m)

        return guaranteed_part + deferred_part




    ## ----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ##                                                         Geometrically increasing annuities
    ## -----------------------------------------------------------------------------------------------------------------------------------------------------------------


    ## ------------------------------------------------------------------
    ##  1: Geometrically Increasing Term (Due /Immediate)
    ## ------------------------------------------------------------------

    def geometrically_increasing_term_annuity(self, x: int, n: int, j: float, timing: str = 'due'):
        """
        Calculates the EPV of a term annuity with geometrically increasing payments.
        The first payment is 1, the second is (1+j), the third is (1+j)^2, etc.

        This is calculated as a level term annuity using an adjusted interest rate i*.

        Args:
            x (int): The age of the insured.
            n (int): The term of the annuity in years.
            j (float): The geometric rate of increase (e.g., 0.02 for 2%).
            timing (str): Type of annuity, '
            due' or 'immediate'. Defaults to 'due'.

        Returns:
            float: The expected present value (EPV) of the annuity.
        """
        # Step 1: Validate inputs
        self.validate_inputs(x, n)
        if 1 + j <= 0:
            raise ValueError("1+j must be positive.")

        # Step 2: Calculate the adjusted interest rate, i*
        i_star = (self.i - j) / (1 + j)

        # Step 3: Create a new, temporary calculator instance with the adjusted rate
        temp_calculator = ActuarialCalculator(
            life_table_df=self.life_table.reset_index(),
            interest_rate=i_star
        )

        # Step 4: Call the standard term_annuity_due on the temporary calculator
        # This is where we reuse our previous work
        annuity_due_val = temp_calculator.term_annuity_due(x, n)

        # Step 5: Return the correct value based on timing
        if timing == 'due':
            return annuity_due_val
        elif timing == 'immediate':
            # The immediate version is the due version minus the first payment of 1
            return annuity_due_val - 1
        else:
            raise ValueError("Timing must be 'due' or 'immediate'.")